Setting up MongoDB
Download mongodb, create a data/db folder on C:/ then run the mongod.exe in the absolute path.

Setting up Node.js
//automatically setup package.js
> npm init -y

Creating Routes
index.js
//better for optimization and represents a data structure that contains information that will never change
const express = require('express');

//set up express app
const app = express();

//initialize routes
app.use('/api', require('./routes/api'));

//listen for requests
//process.env.port will listen for the environment port if they have one
//if not will just manually set port to 4000
app.listen(process.env.port || 4000, function(){
    console.log('now listening for requests');
});

api.js
const express = require('express');
const router = express.Router();

//get a list of ninjas from the db
router.get('/ninjas', function(req, res){
    res.send({type: 'GET'});
});

//add a new ninja to the db
router.post('/ninjas', function(req, res){
    res.send({type: 'POST'});
});

//update a ninja in the db
router.put('/ninjas/:id', function(req, res){
    res.send({type: 'PUT'});
});

//delete a ninja in the db
router.delete('/ninjas/:id', function(req, res){
    res.send({type: 'DELETE'});
});

module.exports = router;

___Postman___
- Test your API's

___Handling POST Requests (& middleware)___
- Code that happens between the app accepting the request, and the app sending the response.
- Request -> Middleware (app.use(middleware)) -> Route Handlers (app.use(./routes/api)) -> Middleware (app.use(middleware)) -> Reponse
- Request -> Body Parser (app.use(body-parser)) -> Route Handlers (app.use(./routes/api)) ->  Reponse

index.js
//better for optimization and represents a data structure that contains information that will never change
const express = require('express');
const bodyParser = require('body-parser');

//set up express app
const app = express();

app.use(bodyParser.json());

//initialize routes
app.use('/api', require('./routes/api'));

//listen for requests
//process.env.port will listen for the environment port if they have one
//if not will just manually set port to 4000
app.listen(process.env.port || 4000, function(){
    console.log('now listening for requests');
});

api.js
const express = require('express');
const router = express.Router();

//get a list of ninjas from the db
router.get('/ninjas', function(req, res){
    res.send({type: 'GET'});
});

//add a new ninja to the db
router.post('/ninjas', function(req, res){
    console.log(req.body);
    res.send({
        type: 'POST',
        name: req.body.name,
        rank: req.body.rank
    });
});

//update a ninja in the db
router.put('/ninjas/:id', function(req, res){
    res.send({type: 'PUT'});
});

//delete a ninja in the db
router.delete('/ninjas/:id', function(req, res){
    res.send({type: 'DELETE'});
});

module.exports = router;

___Models & Schemas___
Models
- Models represent collections in MongoDB
- User Model to represent a collection of Users
- Ninja Model to represent a collection of Ninjas
*a table in sql
Schemas
- Schemas define the structure of our data objects
{
  name: String,
  rank: String,
  availability: Boolean
}
Mongoose
- Adds a layer of methods to easily save, edit, retreive, and delete data from mongodb
- Allows us to create our Models and Schemas easily

ninja.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

//create ninja Schema & model
const NinjaSchema = new Schema({
    name: {
        type: String,
        required: [true, 'Name field is required']
    },
    rank: {
        type: String,
    },
    available: {
        type: Boolean,
        default: false
    }
    // add in geo location
});

const Ninja = mongoose.model('ninja', NinjaSchema);

module.exports = Ninja;

___Saving Data to MongoDB___
api.js
const express = require('express');
const router = express.Router();
const Ninja = require('../models/ninja');

//get a list of ninjas from the db
router.get('/ninjas', function(req, res){
    res.send({type: 'GET'});
});

//add a new ninja to the db
router.post('/ninjas', function(req, res){
    Ninja.create(req.body).then(function(ninja){
        res.send(ninja);
    });
});
// it's normally good practice to send back to the user what they just posted
// Ninja.create(req.body) is actually async meaning the object has to be first created before sending back the ninja

//update a ninja in the db
router.put('/ninjas/:id', function(req, res){
    res.send({type: 'PUT'});
});

//delete a ninja in the db
router.delete('/ninjas/:id', function(req, res){
    res.send({type: 'DELETE'});
});

module.exports = router;

Robomongo
Postman

___Error Handling___
- Request -> Body Parser (app.use(body-parser)) -> Route Handlers (app.use(./routes/api)) -> Middleware -> Reponse
- We're able to tack on a .catch(next) method to all our route apis. Next is there as a callback function to tell us to move onto the next piece of middleware.

index.js
//better for optimization and represents a data structure that contains information that will never change
const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');

//set up express app
const app = express();

//connect to mongodb
mongoose.connect('mongodb://localhost/ninjago')
mongoose.Promise = global.Promise;

app.use(bodyParser.json());

//initialize routes
app.use('/api', require('./routes/api'));

//error handling middleware
app.use(function(err, req, res, next){
    res.status(422).send({error: err.message});
    //console.log(err);
});

//listen for requests
//process.env.port will listen for the environment port if they have one
//if not will just manually set port to 4000
app.listen(process.env.port || 4000, function(){
    console.log('now listening for requests');
});

api.js
const express = require('express');
const router = express.Router();
const Ninja = require('../models/ninja');

//get a list of ninjas from the db
router.get('/ninjas', function(req, res, next){
    res.send({type: 'GET'});
});

//add a new ninja to the db
router.post('/ninjas', function(req, res, next){
    Ninja.create(req.body).then(function(ninja){
        res.send(ninja);
    }).catch(next); //this next is actually called in index.js right after the route portion
});
// it's normally good practice to send back to the user what they just posted
// Ninja.create(req.body) is actually async meaning the object has to be first created before sending back the ninja

//update a ninja in the db
router.put('/ninjas/:id', function(req, res, next){
    res.send({type: 'PUT'});
});

//delete a ninja in the db
router.delete('/ninjas/:id', function(req, res, next){
    res.send({type: 'DELETE'});
});

module.exports = router;

___Handling DELETE Requests___
- Ran into an issue where after I deleted an _id, I could still run the request over and over. I assume this is because it's _id is still kept somewhere in (temporary?) storage. This is also tells me that once an _id is created, another one will never be the same as that _id, even if it were to be deleted.

const express = require('express');
const router = express.Router();
const Ninja = require('../models/ninja');

//get a list of ninjas from the db
router.get('/ninjas', function(req, res, next){
    res.send({type: 'GET'});
});

//add a new ninja to the db
router.post('/ninjas', function(req, res, next){
    Ninja.create(req.body).then(function(ninja){
        res.send(ninja);
    }).catch(next); //this next is actually called in index.js right after the route portion
});
// it's normally good practice to send back to the user what they just posted
// Ninja.create(req.body) is actually async meaning the object has to be first created before sending back the ninja

//update a ninja in the db
router.put('/ninjas/:id', function(req, res, next){
    res.send({type: 'PUT'});
});

//delete a ninja in the db
router.delete('/ninjas/:id', function(req, res, next){
    Ninja.findByIdAndRemove({_id: req.params.id}).then(function(ninja){
        res.send(ninja);
    });
});

module.exports = router;

___PUT Requests___
const express = require('express');
const router = express.Router();
const Ninja = require('../models/ninja');

//get a list of ninjas from the db
router.get('/ninjas', function(req, res, next){
    res.send({type: 'GET'});
});

//add a new ninja to the db
router.post('/ninjas', function(req, res, next){
    Ninja.create(req.body).then(function(ninja){
        res.send(ninja);
    }).catch(next); //this next is actually called in index.js right after the route portion
});
// it's normally good practice to send back to the user what they just posted
// Ninja.create(req.body) is actually async meaning the object has to be first created before sending back the ninja

//update a ninja in the db
router.put('/ninjas/:id', function(req, res, next){
    Ninja.findByIdAndUpdate({_id: req.params.id}, req.body).then(function(){ //the reason we use ninja here is because it returns us the previous entry before we updated
        Ninja.findOne({_id: req.params.id}).then(function(ninja){ // that's why we search the database after the update and then send that dude
            res.send(ninja);
        });
    });
});

//delete a ninja in the db
router.delete('/ninjas/:id', function(req, res, next){
    Ninja.findByIdAndRemove({_id: req.params.id}).then(function(ninja){
        res.send(ninja);
    });
});

module.exports = router;

___GeoJSON___
- a format for encoding a variety of geographic data structures

ninja.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

// create geolocation Schema
const GeoSchema = new Schema({
    type: {
        type: String,
        default: "Point"
    },
    coordinates: {
        type: [Number],
        index: "2dsphere" //the type of map we want to use, mongodb can use 2d or 2dsphere for index apparently
        // 2dsphere simulates an actual globe, as the world isn't flat
    }
});

//create ninja Schema & model
const NinjaSchema = new Schema({
    name: {
        type: String,
        required: [true, 'Name field is required']
    },
    rank: {
        type: String,
    },
    available: {
        type: Boolean,
        default: false
    },
    // add in geo location; uses GeoJson to do this
    geometry: GeoSchema // we could always pop in the GeoSchema data right into here, but it's nice to make things a little modular as to not waste space
});

const Ninja = mongoose.model('ninja', NinjaSchema);

module.exports = Ninja;

___GET Requests___
URL Params
- can add on parameters in request URL's
- [www.ninjago.com/api/ninjas] - route [?lng=50.45&lat=42.35] - url parameter\
- www.ninjago.com/api/ninjas?lng=50.45&lat=42.35

api.js
const express = require('express');
const router = express.Router();
const Ninja = require('../models/ninja');

//get a list of ninjas from the db
router.get('/ninjas', function(req, res, next){
    /*Ninja.find({}).then(function(ninjas){
        res.send(ninjas);
    });*/
    Ninja.geoNear(
        {type: 'Point', coordinates: [parseFloat(req.query.lng), parseFloat(req.query.lat)]}, //values we get from the url will always be a string, but for the coordinates model we specified that it's a array of numbers
        {maxDistance: 100000, spherical: true}
    ).then(function(ninjas){ // its labeled ninjas for readability but it's just the items returned after the function
        res.send(ninjas);
    });/*.catch(function(){
        Ninja.find({}).then(function(ninjas){
            res.send(ninjas);
        });
    });*/
});

//add a new ninja to the db
router.post('/ninjas', function(req, res, next){
    Ninja.create(req.body).then(function(ninja){
        res.send(ninja);
    }).catch(next); //this next is actually called in index.js right after the route portion
});
// it's normally good practice to send back to the user what they just posted
// Ninja.create(req.body) is actually async meaning the object has to be first created before sending back the ninja

//update a ninja in the db
router.put('/ninjas/:id', function(req, res, next){
    Ninja.findByIdAndUpdate({_id: req.params.id}, req.body).then(function(){ //the reason we use ninja here is because it returns us the previous entry before we updated
        Ninja.findOne({_id: req.params.id}).then(function(ninja){ // that's why we search the database after the update and then send that dude
            res.send(ninja);
        });
    });
});

//delete a ninja in the db
router.delete('/ninjas/:id', function(req, res, next){
    Ninja.findByIdAndRemove({_id: req.params.id}).then(function(ninja){
        res.send(ninja);
    });
});

module.exports = router;

ninja.js
const mongoose = require('mongoose');
const Schema = mongoose.Schema;

// create geolocation Schema
const GeoSchema = new Schema({
    type: {
        type: String,
        default: "Point"
    },
    coordinates: {
        type: [Number],
        index: "2dsphere" //the type of map we want to use, mongodb can use 2d or 2dsphere for index apparently
        // 2dsphere simulates an actual globe, as the world isn't flat
    }
});

//create ninja Schema & model
const NinjaSchema = new Schema({
    name: {
        type: String,
        required: [true, 'Name field is required']
    },
    rank: {
        type: String,
    },
    available: {
        type: Boolean,
        default: false
    },
    // add in geo location; uses GeoJson to do this
    geometry: GeoSchema // we could always pop in the GeoSchema data right into here, but it's nice to make things a little modular as to not waste space
});

const Ninja = mongoose.model('ninja', NinjaSchema);

module.exports = Ninja;

___Creating a Front-end___
- babel takes our jsx into usable code in the browser
- react used to make the components
- react-dom used to put them into the dom

index.html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Ninjago</title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
        <link href="/styles.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <h1 class="title">Ninjago - a Ninja REST API</h1>
        <div id="homepage">
            <h1>Hire a ninja in your area!</h1>
            <div id="ninjas"></div>
        </div>

        <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
        <script src="https://unpkg.com/react@15/dist/react.js"></script>
        <script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"></script>
    </body>
</html>

___Creating a React Component___
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Ninjago</title>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">
        <link href="/styles.css" rel="stylesheet" type="text/css" />
    </head>
    <body>
        <h1 class="title">Ninjago - a Ninja REST API</h1>
        <div id="homepage">
            <h1>Hire a ninja in your area!</h1>
            <div id="ninjas"></div>
        </div>

        <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
        <script src="https://unpkg.com/react@15/dist/react.js"></script>
        <script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"></script>

        <!-- Create React Component -->
        <script type="text/babel">

        var Ninjas = React.createClass({
            getInitialState: function(){
                return({
                    ninjas: []
                });
            },
            render: function(){
                var ninjas = this.state.ninjas;
                ninjas = ninjas.map(function(ninja, index){
                    return(
                        <li key={index}>
                            <span className={ninja.obj.available}></span>
                            <span className="name">{ninja.obj.name}</span>
                            <span className="rank">{ninja.obj.rank}</span>
                            <span className="dist">{Math.floor(ninja.dis / 1000)} km</span>
                        </li>
                    );
                });
                return(
                    <div id="ninja-container">
                        <form id="search" onSubmit={this.handleSubmit}>
                            <label>Enter your longitude:</label>
                            <input type="text" ref="lng" placeholder="longitude" required />
                            <label>Enter your latitude:</label>
                            <input type="text" ref="lat" placeholder="latitude" required />
                            <input type="submit" value="Find Ninjas" />
                        </form>
                        <ul>{ninjas}</ul>
                    </div>
                );
            },
            handleSubmit: function(e){
                e.preventDefault();
                var lng = this.refs.lng.value;
                var lat = this.refs.lat.value;

                fetch('/api/ninjas?lng=' + lng + '&lat=' + lat).then(function(data){
                    return data.json();
                }).then( json => {
                    this.setState({
                        ninjas: json
                    });
                    console.log(json);
                });
            }
        });

        ReactDOM.render(<Ninjas />, document.getElementById('ninjas'));

        </script>
    </body>
</html>